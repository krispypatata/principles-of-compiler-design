lexer.py
```
import sys
import re

######################################################################################################
# MULT-LINE VALIDATOR
######################################################################################################
# Function for tokenizing a string of characters based on a set of token patterns.
def lex(characters, token_exprs):
    pos = 0             # Current position in the input string
    tokens = []         # List to hold the tokenized output
    line_number = 1     # Start with line number 1

    # Traverse through the contents of the input
    while pos < len(characters):
        match = None # Flag to track whether a match is found for the current position

        # traverse through the list of regex patterns for tokens
        for token_expr in token_exprs:
            pattern, tag = token_expr               # Extract regex pattern and tag from token_expr; ex. ('HAI', 'Reserved')
            regex = re.compile(pattern)             # Compile the regex
            match = regex.match(characters, pos)    # Try to match the pattern at the current position
            
            # If there's a match, get the matched text
            if match:
                text = match.group(0)

                # But only add token to the list if it has a valid tag 
                if tag:
                    token = (text, tag, line_number)
                    tokens.append(token)

                # Update line count if a newline is encountered in the matched text
                line_number += text.count('\n')

                 # Exit the loop once a match is found
                break

        # If there's no match found, then there's an error
        if not match:
            sys.stderr.write("Illegal character: '%s' at %d\n" % (characters[pos], line_number))
            sys.exit(1)
        
        # If match found, move the position pointer to the end of the matched text
        else:
            pos = match.end(0)
    
    # Return the list of tokens
    return tokens



######################################################################################################
# MULT-LINE VALIDATOR
######################################################################################################
# Function to check if a certain word in a line is inside a string or not
def is_word_in_quotes(line, word):
    return bool(re.search(rf'"[^"]*\b{re.escape(word)}\b[^"]*"', line))


# Function to validate multiline comments in the input text.
# Ensures that:
# - 'OBTW' starts a block and is properly closed by 'TLDR' on a separate line.
# - 'TLDR' does not appear without a preceding 'OBTW'.
# - 'OBTW' and 'TLDR' do not coexist on the same line unless both are inside a string.
# - 'OBTW' is only preceded by whitespace/s, and 'TLDR' is only followed by whitespace/s.
def validate_multiline_comments(characters) :
    # print(characters) # For debugging

    inside_obtw = False                 # Flag to track if we're inside an OBTW block
    found_tldr_without_obtw = False     # Flag to track standalone TLDR

    # Traverse through the contents of the input
    for line_number, line in  enumerate(characters.splitlines(), 1):
        # Check if both OBTW and TLDR are on the same line
        # Raise an error if they are
        if re.search(r'\bOBTW\b', line) and re.search(r'\bTLDR\b', line):
            if not (is_word_in_quotes(line, 'OBTW') and is_word_in_quotes(line, 'TLDR')):
                sys.stderr.write(f"Error: 'OBTW' and 'TLDR' cannot coexist on the same line (line {line_number}).\n")
                sys.exit(1)

        # Validate the existence of the 'OBTW' keyword
        if re.search(r'\bOBTW\b', line):
            # Skip if 'OBTW' is inside a string
            if is_word_in_quotes(line, 'OBTW'):
                continue            

            # Skip if inside an OBTW block
            if inside_obtw:         
                continue

            # Skip if 'OBTW' is preceded by whitespace/s only
            if line.lstrip().startswith("OBTW"):
                inside_obtw = True  # Set flag to indicate we're inside an OBTW block
                continue            

            # Raise an error if 'OBTW' is preceded by anything other than whitespace/s
            sys.stderr.write(f"Error: 'OBTW' multiline comment keyword at line {line_number} can only be preceded by whitespace/s.\n")
            sys.exit(1)

        # Validate the existence of the 'TLDR' keyword
        if re.search(r'\bTLDR\b', line):
            # Skip if 'TLDR' is inside a string
            if is_word_in_quotes(line, 'TLDR') and not inside_obtw:
                continue
            
            # Skip if 'TLDR' is followed by whitespace/s only
            # But first check if it has a valid 'OBTW' pair
            if line.rstrip().endswith("TLDR"):
                if not inside_obtw:  # TLDR found without a preceding OBTW
                    found_tldr_without_obtw = True

                inside_obtw = False  # Reset the flag when exiting the block
                continue

            # Raise an error if 'OBTW' is followed by anything other than whitespace/s
            sys.stderr.write(f"Error: 'TLDR' multiline comment keyword at line {line_number} can only be followed by whitespace/s.\n")
            sys.exit(1)
    
    # Ensure that there's a closing TLDR if we left the block open
    if inside_obtw:
        sys.stderr.write(f"Error: Missing 'TLDR' to close the 'OBTW' block.\n")
        sys.exit(1)

    # Ensure that TLDR does not appear without a preceding OBTW
    if found_tldr_without_obtw:
        sys.stderr.write("Error: Found 'TLDR' without a preceding 'OBTW'.\n")
        sys.exit(1)
######################################################################################################




######################################################################################################
# TOKENIZING
######################################################################################################
# INDICES
TOKEN_VALUE = 0
TOKEN_TAG = 1
TOKEN_LINE_NUMBER = 2

# Keywords

# Proram keywords, variables
HAI = 'Program Start Delimeter'
KTHXBYE = 'Program End Delimeter'
WAZZUP = 'Variable Declaration Start Delimeter'
BUHBYE = 'Variable Declaration End Delimeter'
I_HAS_A ='Variable Declaration'
ITZ = 'Variable Initialization'
R = 'Assignment Keyword'

# Arithmetic Operations
SUM_OF = 'Addition Operator'
DIFF_OF = 'Subtraction Operator'
PRODUKT_OF = 'Multiplication Operator'
QUOSHUNT_OF = 'Division Operator'
MOD_OF = 'Modulus Operator'
BIGGR_OF = 'Greater Than Operator'
SMALLR_OF = 'Less Than Operator'
BOTH_OF = 'AND Operator'
EITHER_OF = 'OR Operator'
WON_OF = 'XOR Operator'
NOT = 'NOT Operator'
ANY_OF = 'ANY Operator'
ALL_OF = 'ALL Operator'
BOTH_SAEM = 'Equality Operator'
DIFFRINT = 'Inequality Operator'
SMOOSH = 'String Concatenate Operator'
MAEK = 'Typecast MAEK Operator'
A = 'Typecast Specifier'
IS_NOW_A = 'Typecast IS NOW A Operator'

# Part of the expression for operands
AN = 'Operand Connector'
YR = 'Parameter Variable'
AN_YR = 'Additional Parameter Variable'

# Statements
VISIBLE = 'Print Statement'
VISIBLE_OPERATOR = 'Print Statement Delimiter'
GIMMEH = 'Input Statement'
O_RLY = 'Conditional Start Delimeter'
YA_RLY = 'If Clause'
MEBBE = 'Else-If Clause'
NO_WAI = 'Else Clause'
OIC = 'Conditional End Delimeter'
WTF = 'Switch-Case Start Delimeter'
OMG = 'Case Clause'
OMGWTF = 'Switch-Case End Delimeter'
IM_IN_YR = 'Loop Start Delimeter'
UPPIN = 'Increment Operator'
NERFIN = 'Decrement Operator'
TIL = 'Until Loop'
WILE = 'While Loop'
IM_OUTTA_YR = 'Loop End Delimeter'
# Functions
HOW_IZ_I = 'Function Start Delimeter'
IF_U_SAY_SO = 'Function End Delimeter'
GTFO = 'Function Return'
FOUND_YR = 'Function Return Value'
I_IZ = 'Function Call'
MKAY = 'Statement End Delimeter'

# Literals
NUMBR = 'Integer'
NUMBAR = 'Float'
TROOF = 'Boolean'
YARN = 'String'
LITERAL_TYPE = 'Literal Type'

# Identifier
IDENTIFIER = 'Identifier'

# End of File
EOF = 'End of File'

# Make sure that the pattern matches as a whole word, excluding it from being part of larger words.
def bound(pattern):
    return rf'(?<!\w){pattern}(?!\w)'

token_exprs = [
    (r'[ \n\t]+',                             None),   # whitespace (ignore)
    (r'BTW[^\n]*',                            None),   # single line comments (ignore)
    (r'OBTW\s*((.|\n)*?)\s*TLDR',             None),   # multi-line comments (ignore)
    (bound('HAI'),                            HAI),
    (bound('KTHXBYE'),                        KTHXBYE),
    (bound('WAZZUP'),                         WAZZUP),
    (bound('BUHBYE'),                         BUHBYE),
    (bound('I HAS A'),                        I_HAS_A),
    (bound('ITZ'),                            ITZ),
    (bound('R'),                              R),
    (bound('SUM OF'),                         SUM_OF),
    (bound('DIFF OF'),                        DIFF_OF),
    (bound('PRODUKT OF'),                     PRODUKT_OF),
    (bound('QUOSHUNT OF'),                    QUOSHUNT_OF),
    (bound('MOD OF'),                         MOD_OF),
    (bound('BIGGR OF'),                       BIGGR_OF),
    (bound('SMALLR OF'),                      SMALLR_OF),
    (bound('BOTH OF'),                        BOTH_OF),
    (bound('EITHER OF'),                      EITHER_OF),
    (bound('WON OF'),                         WON_OF),
    (bound('NOT'),                            NOT),
    (bound('ANY OF'),                         ANY_OF),
    (bound('ALL OF'),                         ALL_OF),
    (bound('AN YR'),                          AN_YR),
    (bound('AN'),                             AN),
    (bound('BOTH SAEM'),                      BOTH_SAEM),
    (bound('DIFFRINT'),                       DIFFRINT),
    (bound('SMOOSH'),                         SMOOSH),
    (bound('MAEK'),                           MAEK),
    (bound('A'),                              A),
    (bound('IS NOW A'),                       IS_NOW_A),
    (bound('VISIBLE'),                        VISIBLE),
    (bound('GIMMEH'),                         GIMMEH),
    (bound('O RLY\?'),                        O_RLY),
    (bound('YA RLY'),                         YA_RLY),
    (bound('MEBBE'),                          MEBBE),
    (bound('NO WAI'),                         NO_WAI),
    (bound('OIC'),                            OIC),
    (bound('WTF\?'),                          WTF),
    (bound('OMG'),                            OMG),
    (bound('OMGWTF'),                         OMGWTF),
    (bound('IM IN YR'),                       IM_IN_YR),
    (bound('UPPIN'),                          UPPIN),
    (bound('NERFIN'),                         NERFIN),
    (bound('YR'),                             YR),
    (bound('TIL'),                            TIL),
    (bound('WILE'),                           WILE),
    (bound('IM OUTTA YR'),                    IM_OUTTA_YR),
    (bound('HOW IZ I'),                       HOW_IZ_I),
    (bound('IF U SAY SO'),                    IF_U_SAY_SO),
    (bound('GTFO'),                           GTFO),
    (bound('FOUND YR'),                       FOUND_YR),
    (bound('I IZ'),                           I_IZ),
    (bound('MKAY'),                           MKAY),
    (r'\+',                                   VISIBLE_OPERATOR),
    (bound('-?[0-9]+\.[0-9]+'),               NUMBAR),          # Float
    (bound('-?[0-9]+'),                       NUMBR),           # Integer
    (bound('"[^"]*"'),                        YARN),            # String
    (bound('(WIN|FAIL)'),                     TROOF),           # Boolean
    (bound('(NOOB|NUMBR|NUMBAR|YARN|TROOF)'), LITERAL_TYPE),    # Type
    (bound('[a-zA-Z][a-zA-Z0-9_]*'),          IDENTIFIER),      # Identifier
]

def lolcode_lex(characters):
    validate_multiline_comments(characters) # Validate the existence of multi-line comments
    return lex(characters, token_exprs)
```

parser.py
```
from lexer import *

#################################
class Error:
  def __init__(self, token, details, error_name):
    self.token = token
    self.details = details
    self.error_name = error_name
  def as_string(self):
    return f"{self.error_name}: '{self.token[TOKEN_VALUE]}' at line {self.token[TOKEN_LINE_NUMBER]}\nDetails: {self.details}\n"

class InvalidSyntaxError(Error):
  def __init__(self, token, details):
    super().__init__(token, details, error_name='Invalid Syntax')


class RuntimeError(Error):
  def __init__(self, token, details):
    super().__init__(token, details, error_name='Runtime Error')

#######################################
# NODES
#######################################
class IntegerNode:
  def __init__(self, token):
    self.token = token

  def __repr__(self):
    return f'{self.token[TOKEN_VALUE]}'

class FloatNode:
  def __init__(self, token):
    self.token = token

  def __repr__(self):
    return f'{self.token[TOKEN_VALUE]}'

class ArithmeticBinaryOpNode:
  def __init__(self, left_node, operation, right_node):
    self.operation = operation
    self.left_node = left_node
    self.right_node = right_node

  def __repr__(self):
    return f'{self.operation[TOKEN_VALUE]}({self.left_node}, {self.right_node})'

class VarAccessNode:
  def __init__(self, var_name_token):
    self.var_name_token = var_name_token

  def __repr__(self):
    return f"VarAccess({self.var_name_token[TOKEN_VALUE]})"

class VarAssignNode:
  def __init__(self, var_name_token, value_node):
    self.var_name_token = var_name_token
    self.value_node = value_node

  def __repr__(self):
    return f"VarAssign({self.var_name_token[TOKEN_VALUE]}, {self.value_node})"

#######################################
# PARSE RESULT
#######################################
class ParseResult:
  def __init__(self):
    self.error = None
    self.node = None
    self.advance_count = 0

  def register_advancement(self):
    self.advance_count += 1

  def register(self, res):
    self.advance_count += res.advance_count
    if res.error: self.error = res.error
    return res.node

  def success(self, node):
    self.node = node
    return self

  def failure(self, error):
    if self.error is None: self.error = error
    return self
  
#######################################
# PARSER
#######################################

class Parser:
  def __init__(self, tokens):
    self.tokens = tokens
    self.token_index = -1
    self.advance()

  def advance(self):
    self.token_index += 1
    if (self.token_index < len(self.tokens)):
      self.current_token = self.tokens[self.token_index]
    return self.current_token

  def parse(self):
    res = self.expr()

    # Unparsed tokens
    if res is None or (not res.error and self.current_token[TOKEN_TAG] != EOF):
      return ParseResult().failure(InvalidSyntaxError(self.current_token, 'Unexpected Syntax'))
    return res


  def expr(self):
    if self.current_token[TOKEN_TAG] in (PRODUKT_OF, QUOSHUNT_OF, SUM_OF, DIFF_OF, BIGGR_OF, SMALLR_OF):
      return self.arithmetic_binary_operation()

    elif self.current_token[TOKEN_TAG] in (NUMBR, NUMBAR):
      return self.atom()

    elif self.current_token[TOKEN_TAG] in (I_HAS_A):
      return self.variable_declaration()

  def variable_declaration(self):
    res = ParseResult()

    if self.current_token[TOKEN_TAG] in (I_HAS_A):
      res.register_advancement()
      self.advance() # eats I has a

      if (self.current_token[TOKEN_TAG] != IDENTIFIER):
        return res.failure(InvalidSyntaxError(self.current_token, "Expected Identifier!"))

      var_name_token = self.current_token
      res.register_advancement()
      self.advance() # eats var name
      
      if (self.current_token[TOKEN_TAG] != ITZ):
        return res.failure(InvalidSyntaxError(self.current_token, "Expected 'ITZ'!"))

      res.register_advancement()
      self.advance() # eats ITZ

      expr = res.register(self.expr())
      if res.error: return res

      return res.success(VarAssignNode(var_name_token, expr))

  def arithmetic_binary_operation(self):
    res = ParseResult()
    
    if self.current_token[TOKEN_TAG] in (PRODUKT_OF, QUOSHUNT_OF, SUM_OF, DIFF_OF, BIGGR_OF, SMALLR_OF):
      operation = self.current_token
      res.register_advancement()
      self.advance()
      
      # Parse the left operand
      left = res.register(self.arithmetic_factor())  # Recursive call to handle the left side
      if res.error: return res

      # check for 'AN' keyword 
      if self.current_token[TOKEN_TAG] != AN:
          # print(self.current_token[TOKEN_VALUE])
          return res.failure(InvalidSyntaxError(self.current_token, "Expected an 'AN' keyword!"))
          
      # Advance past the 'AN' keyword
      res.register_advancement()
      self.advance()

      # Parse the right operand which may also be an expression
      right = res.register(self.arithmetic_factor())  # Recursive call to handle right side
      if res.error: return res

      # Return an operation node with left and right operands
      return res.success(ArithmeticBinaryOpNode(left, operation, right))

  def arithmetic_factor(self):
    res = ParseResult()
    token = self.current_token

    if token[TOKEN_TAG] in (NUMBR, NUMBAR):
      return res.register(self.atom())
    
    elif token[TOKEN_TAG] in (PRODUKT_OF, QUOSHUNT_OF, SUM_OF, DIFF_OF, BIGGR_OF, SMALLR_OF):
      return res.register(self.arithmetic_binary_operation())

  def atom(self):
    res = ParseResult()
    token = self.current_token

    if token[TOKEN_TAG] in (NUMBR, NUMBAR):
      res.register_advancement()
      self.advance()
      
      if token[TOKEN_TAG] == NUMBR:
        return res.success(IntegerNode(token))
      else:
        return res.success(FloatNode(token))

    elif token[TOKEN_TAG] == IDENTIFIER:
      res.register_advancement()
      self.advance()
      return res.success(VarAccessNode(token))

    return res.failure(InvalidSyntaxError(token, 'Expected int or float!'))
  

#######################################
# RUNTIME RESULT
#######################################
class RTResult:
  def __init__(self):
    self.value = None
    self.error = None
  
  def register(self, res):
    if res.error: self.error = res.error
    return res.value
  
  def success(self, value):
    self.value = value
    return self
  
  def failure(self, error):
    self.error = error
    return self

#######################################
# VALUES
#######################################
class Number:
  def __init__(self, value, line_number=None):
    self.value = value
    self.line_number = line_number
    self.set_context()

  def set_context(self, context=None):
    self.context = context
    return self

  def added_by(self, other):
    if isinstance(other, Number):
      return Number(self.value + other.value).set_context(self.context) , None

  def subtracted_by(self, other):
    if isinstance(other, Number):
      return Number(self.value - other.value).set_context(self.context) , None
  
  def multiplied_by(self, other):
    if isinstance(other, Number):
      return Number(self.value * other.value).set_context(self.context) , None
  
  def divided_by(self, other):
    if isinstance(other, Number):
      if other.value == 0:
        return None, RuntimeError(
          ('Result is Zero', None, other.line_number), 'Division by Zero'
        )
      return Number(self.value / other.value).set_context(self.context) , None
  
  def greater_than(self, other):
    if isinstance(other, Number):
      return Number(max(self.value, other.value)).set_context(self.context) , None

  def less_than(self, other):
    if isinstance(other, Number):
      return Number(min(self.value, other.value)).set_context(self.context) , None

  def __repr__(self):
    return str(self.value)
  
#######################################
# CONTEXT
#######################################
class Context:
  def __init__(self, display_name, parent=None, parent_entry_pos=None):
    self.display_name = display_name
    self.parent = parent
    self.parent_entry_pos = parent_entry_pos
    self.symbol_table = None

#######################################
# SYMBOL_TABLE
#######################################
class SymbolTable:
  def __init__(self):
    self.symbols = {}
    self.parent = None # For functions (definitions/calls)
  
  def get(self, name):
    value = self.symbols.get(name, None)
    if value == None and self.parent:
      return self.parent.get(name)
    return value

  def set(self, name, value):
    self.symbols[name] = value

  def remove(self, name):
    del self.symbols[name]

#######################################
# INTERPRETER
#######################################
class Interpreter:
  def visit(self, node, context):
    method_name = f'visit_{type(node).__name__}'
    method = getattr(self, method_name, self.no_visit_method)
    return method(node, context)
  
  def no_visit_method(self, node, context):
    raise Exception(f'No visit_{type(node).__name__} method defined')
  
  def visit_IntegerNode(self, node, context):
    # print("Found integer node")
    return RTResult().success(
      Number(int(node.token[TOKEN_VALUE]), node.token[TOKEN_LINE_NUMBER])
    )
  
  def visit_FloatNode(self, node, context):
    # print("Found float node")
    return RTResult().success(
      Number(float(node.token[TOKEN_VALUE]), node.token[TOKEN_LINE_NUMBER])
    )
  
  def visit_ArithmeticBinaryOpNode(self, node, context):
    # print("Found ar bin op node")
    res = RTResult()
    left = res.register(self.visit(node.left_node, context))
    if res.error: return res
    right = res.register(self.visit(node.right_node, context))
    if res.error: return res

    if node.operation[TOKEN_TAG] == SUM_OF:
      result, error = left.added_by(right)

    elif node.operation[TOKEN_TAG] == DIFF_OF:
      result, error = left.subtracted_by(right)
    
    elif node.operation[TOKEN_TAG] == PRODUKT_OF:
      result, error = left.multiplied_by(right) 

    elif node.operation[TOKEN_TAG] == QUOSHUNT_OF:
      result, error = left.divided_by(right)
    
    elif node.operation[TOKEN_TAG] == BIGGR_OF:
      result, error = left.greater_than(right)
    
    elif node.operation[TOKEN_TAG] == SMALLR_OF:
      result, error = left.less_than(right)

    if (error):
      return res.failure(error)
    else:
      # print(result)
      return res.success(result)

  def visit_VarAccessNode(self, node, context):
    res = RTResult()
    var_name = node.var_name_token[TOKEN_VALUE]

    value = res.register(self.visit(node.value_node, context))

    if not value:
      return res.failure(RuntimeError(node.var_name_token, f"'{var_name} is not defined!'"))
    
    return res.success(value)

  def visit_VarAssignNode(self, node, context):
    res = RTResult()
    var_name = node.var_name_token[TOKEN_VALUE]

    value = res.register(self.visit(node.value_node, context))
    if res.error: return res

    context.symbol_table.set(var_name, value)
    return res.success(value)
```

lolcode.py
```
import sys
from lexer import *
from parser import *

global_symbol_table = SymbolTable()
global_symbol_table.set("IT", Number(0))

def run():
    # characters = '''QUOSHUNT OF SUM OF PRODUKT OF 4 AN 9 AN SUM OF 3 AN 9 AN SMALLR OF 6 AN 9'''
    # characters = '''QUOSHUNT OF SUM OF PRODUKT OF 4 AN 9    SUM OF 3 AN 9 AN SMALLR OF 6 AN 9'''
    # characters = '''PRODUKT OF 4  9'''
    characters = '''9'''
    characters = '''I HAS A var1 ITZ SUM OF 12 AN 4'''
    print('Input Text:')
    print(characters)

    # Generate Tokens
    tokens = lolcode_lex(characters)
    tokens.append(('EOF', EOF, tokens[-1][TOKEN_LINE_NUMBER])) # Add end of line

    print('\nTokens:')
    print(tokens)

    # Generate ast
    lolcode_parser = Parser(tokens)
    ast = lolcode_parser.parse()
    if ast.error: return None, ast.error

    print('\nAST:')
    print(ast.node)

    # Run program
    lolcode_interpreter = Interpreter()
    context = Context('<program>')
    context.symbol_table = global_symbol_table
    result = lolcode_interpreter.visit(ast.node, context)

    return result.value, result.error

# For testing the implementation of the program
if __name__ == '__main__':
    # filename = sys.argv[1]
    # filename = 'test_lex1.lol'
    # file = open(filename)
    # characters = file.read()
    # file.close()
    result, error = run()

    if error: print(error.as_string())
    else: 
        print(result)

```


